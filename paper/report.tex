\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{lmodern}
\geometry{a4paper, margin=2.5cm}

\title{Assignment 1: Basic Matrix Multiplication in Different Languages}
\author{Jaime Rivero Santana \\ Degree in Data Science and Engineering \\ University of Las Palmas de Gran Canaria}
\date{October 20, 2024}

\begin{document}

\maketitle

\begin{abstract}
This report presents a comparative benchmark of the basic matrix multiplication algorithm ($O(n^3)$) implemented in three programming languages: C, Java, and Python. Execution times were measured for square matrices of sizes 100, 200, 500, and 1000. Results show that C and Java achieve highly efficient performance, while Python is significantly slower due to its interpreted nature. The cubic time complexity is clearly observed as execution time scales with $n^3$.
\end{abstract}

\section{Introduction}
Matrix multiplication is a fundamental operation in Big Data and scientific computing. This assignment implements the naive $O(n^3)$ algorithm in C, Java, and Python to compare raw computational performance without external libraries. The goal is to evaluate how language design and runtime environment affect execution time.

\section{Methodology}
All implementations use the same triple-nested loop structure:
\item For each row $i$ in matrix A
    \item For each column $j$ in matrix B
    \item Compute $C[i][j] = \sum_{k=0}^{n-1} A[i][k] \cdot B[k][j]$
Matrices are square ($n \times n$), filled with random values in $[0, 1)$, and initialized with seed 42 for reproducibility. Each experiment was repeated 3 times; average time reported. Timing tools:
\item C: \texttt{clock\_gettime(CLOCK\_MONOTONIC)}
    \item Java: \texttt{System.nanoTime()}
    \item Python: \texttt{time.perf\_counter()}

\section{Results}
Average execution time (seconds):

\begin{center}
\begin{tabular}{crrr}
\toprule
Matrix size ($n$) & C & Java & Python \\
\midrule
100 & 0.001843 & 0.001331 & 0.051941 \\
200 & 0.008965 & 0.006810 & 0.404254 \\
500 & 0.119080 & 0.082889 & 6.560263 \\
1000 & 0.956151 & 0.766837 & 55.027762 \\
\bottomrule
\end{tabular}
\end{center}

\section{Discussion}
Java slightly outperforms C, likely due to JIT optimization after the first loop iteration, while the C implementation uses \texttt{double**} (non-cache-friendly). Python is 28x–58x slower, reflecting interpreted overhead and dynamic list structures. Time increases by ~8x when $n$ doubles (e.g., 500→1000), confirming $O(n^3)$ complexity.

\section{Conclusion}
Language choice critically impacts performance in compute-intensive tasks. C and Java are suitable for raw matrix operations, while Python requires optimized libraries (e.g., NumPy) for scalability. These insights are essential for Big Data practitioners selecting tools for data-intensive workloads.

\section*{Repository}
All code and data: \url{https://github.com/JaimeRiveroSantana/Task1-Language-Benchmark-of-matrix-multiplication}

\end{document}
